#ifndef _VK_C_SETUP_
#define _VK_C_SETUP_

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vulkan/vulkan.h>

#define VKCS_VERBOSE

#ifdef VKCS_VERBOSE
#define VkCS_LOG(x) printf(x);
#else
#define VkCS_LOG(x) ;
#endif

//! if valdiation layers are enabled you must destroy the
//! VkDebugUtilsMessengerEXT yourself
void VkCS_DestroyDebugUtilsMessengerEXT(
    VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger,
    const VkAllocationCallbacks *pAllocator);

//! this struct holds the parameters used by the VkC_BuildInstance function
struct InstanceBuilder {
  const char *AppName;    //!< specifies the name of the app
  uint32_t AppVersion;    /*!< specifies the version of the app this version is
                             generated by using VK_MAKE_VERSION */
  const char *EngineName; //!< specifies the name of the game engine
  uint32_t EngineVersion; /*!< specifies the version of the engine, this is
                             generated by using VK_MAKE_VERSION */
  uint32_t ApiVersion;    //!< specifies the version of Vulkan to be used

  uint32_t LayerCount;           //!< specifies the ammount of layers
  const char *const *LayerNames; //!< contains the names of layers to be used
  uint32_t ExtentionCount; //!< contains the names of extentions to be used
  const char *const
      *ExtentionNames; //!< contains the names of extentions to be used

  VkBool32 (*DebugCallback)(
      VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageTypeFlagsEXT,
      const VkDebugUtilsMessengerCallbackDataEXT *,
      void *); /*!< contains a debug callback function, when set to NULL
                  VkCSetup will use its default Debug Messager */
  bool EnableDebugMessager; /*!< whether or not to use the
                            debug messager provided by
                            VkCSetup, if enabled
                            ExtentionNames must contain
                            VK_EXT_DEBUG_UTILS_EXTENSION_NAME
                            and LayerNames must contain
                            VK_LAYER_KHRONOS_validation*/
} typedef InstanceBuilder;

//! this struct holds the values returned by the VkC_BuildInstance function
struct InstanceBuilderReturn {
  VkInstance Instance;                     /*!< A vulkan Instance */
  VkDebugUtilsMessengerEXT DebugMessenger; //!< a debug messenger
} typedef InstanceBuilderReturn;

//! builds the physical instance
InstanceBuilderReturn VkCS_BuildInstance(InstanceBuilder *Builder);

/*! specifies the requirements a physical device should
 * meet to be selected*/
struct PhysicalDeviceBuilder {
  VkSurfaceKHR *Surface; //! A pointer to a surface
  VkInstance *Instance;  //! A vulkan instnace
  bool (*isSuitableDevice)(
      VkPhysicalDevice *); //! callback to check if GPU is suitable, if set to
                           //! NULL VkCSetup will perfer a descrete gpu
} typedef PhysicalDeviceBuilder;

//! this struct holds the values returned by the VkC_BuildPhysicaldevice
//! function
struct PhysicalDeviceBuilderReturn {
  VkPhysicalDevice PhysicalDevice; //! A VkPhysicalDevice
  int GraphicsQueueIndex;          //! the index to the graphics queue
  int PresentQueueIndex;           //! the index to the present queue
} typedef PhysicalDeviceBuilderReturn;

//! builds the physical device
PhysicalDeviceBuilderReturn
VkCS_BuildPhysicalDevice(PhysicalDeviceBuilder *Builder);

struct DeviceBuilder {
  PhysicalDeviceBuilderReturn *PDBuilderReturn;
  VkPhysicalDeviceFeatures *deviceFeatures;
  int LayerCount;
  const char *const *LayerNames;
} typedef DeviceBuilder;

struct DeviceBuilderReturn {
  VkDevice Device;
  VkQueue GraphicsQueue;
  VkQueue PresentQueue;
} typedef DeviceBuilderReturn;

DeviceBuilderReturn VkCS_BuildLogicalDevice(DeviceBuilder *Builder);

struct SwapChainBuilder {
  DeviceBuilderReturn *DBR;
} typedef SwapChainBuilder;

struct SwapChainBuilderReturn {

} typedef SwapChainBuilderReturn;

SwapChainBuilderReturn VkCS_BuildSwapChain(SwapChainBuilder *Builder);

#endif
